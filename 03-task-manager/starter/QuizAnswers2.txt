1. In this lesson, you created a middleware function called asyncWrapper. Why?

Its purpose is to handle asynchronous operations within Express middleware chains.
It wraps asynchronous functions, typically route handlers, to catch any errors that might occur during their execution using a try-catch block.
By doing so, it ensures that errors are properly handled and passed to Express's error handling middleware (next(error)).
This approach simplifies error handling and makes the code more concise and maintainable.

2. Suppose that you want to make sure that both a status code and an error message are sent back to the user when they request the URL for a task that does not exist.
Assume that youâ€™ve created a CustomAPIError class and an error handler that references that class.
Complete the code:

const getTask = asyncWrapper(async (req, res, next) => {
  const { id: taskID } = req.params;
  const task = await Task.findOne({ _id: taskID });
  if (!task) {
    return next(createCustomError(`No task with id : ${taskID}`, 404));
  }
  res.status(200).json({ task });
});
